<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>数据结构与算法javascript描述学习笔记（13） | hexo荡漾的web博客|傻屌一枚</title>
  <meta name="keywords" content="javascript">
  <meta name="description" content="本次学习一种列表:链表。此书会解释为什么有时链表优于数组,还会实现一个基于对象的链表。本章末尾是几个实际案例,讲解如何使用链表来解决一些编程问题。 链表">
  <link rel="alternative" href="/atom.xml" title="hexo荡漾的web博客|傻屌一枚" type="application/atom+xml">
  <link rel="icon" href="/assets-cdn.github.com/favicon.ico">
  <link rel="stylesheet" href="http://7xnv26.com1.z0.glb.clouddn.com/yuanye/css/style.css">
  <script>var qiniu='http://7xnv26.com1.z0.glb.clouddn.com/';</script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xnv26.com1.z0.glb.clouddn.com/yuanye/img/lufy.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">荡漾</a></h1>
		</hgroup>

		
		<p class="header-subtitle">成为码神一样的技术达人</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/yuanye097" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="mailto:231306299@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/sass/" style="font-size: 10px;">sass</a> <a href="/tags/sublime-Text/" style="font-size: 10px;">sublime Text</a> <a href="/tags/七牛云/" style="font-size: 10px;">七牛云</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.52cik.com/">码神</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">热爱web前端，努力成为像码神一样的技术达人！</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">荡漾</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xnv26.com1.z0.glb.clouddn.com/yuanye/img/lufy.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">荡漾</h1>
			</hgroup>
			
			<p class="header-subtitle">成为码神一样的技术达人</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/yuanye097" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="mailto:231306299@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-data-structure-thirteen" class="article article-type-post" itemscope itemprop="blogPost">
<div class="article-meta">
<a href="/2016/05/10/data-structure-thirteen/" class="article-date">
  	<time datetime="2016-05-10T06:05:00.000Z" itemprop="datePublished">2016-05-10</time>
</a>
</div>

  <div class="article-inner">
      <input type="hidden" class="isFancy" />
          <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数据结构与算法javascript描述学习笔记（13）
    </h1>
  

      </header>

      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/学习日妓/">学习日妓</a>
	</div>


        <div class="clearfix"></div>
      </div>
    <div class="article-entry" itemprop="articleBody">
        <p>本次学习一种列表:链表。此书会解释为什么有时链表优于数组,还会实现一个基于对象的链表。本章末尾是几个实际案例,讲解如何使用链表来解决一些编程问题。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><a id="more"></a>
<h4 id="6-1-数组的缺点"><a href="#6-1-数组的缺点" class="headerlink" title="6.1 数组的缺点"></a>6.1 数组的缺点</h4><p>数组不总是组织数据的最佳数据结构，原因如下。在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再要加入新的元素就会非常困难。在数组中，添加和删除元素也很麻烦，因为需要将数组中的其他元素向前或向后平移，以反映数组刚刚进行了添加或删除操作。然后，JavaScript的数组并不存在上述问题，因为使用split()方法不需要再访问数组中的其他元素了。<br>JavaScript中数组的主要问题是，他们被实现成了对象，与其他语言（比如C++和Java）的数组相比，效率很低。<br>如果发现数组的实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，链表几乎可以用在任何可以使用一维数组的情况中。如果需要随机访问，数组仍然是更好的选择。</p>
<h4 id="6-2-定义链表"><a href="#6-2-定义链表" class="headerlink" title="6.2 定义链表"></a>6.2 定义链表</h4><p>链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一个节点的引用叫做链。如图6-1<br><img src="http://7xnv26.com1.z0.glb.clouddn.com/image/jpg/6-1.png" alt="图6-1"><br>数组元素靠它们的位置进行引用，链表元素则是靠相互之间的关系进行引用。在图6-1中，我们说bread跟在milk后面，而不说bread是链表中的第二个元素。遍历链表，就是跟着链接，从链表的首元素一直走到尾元素（但这不包含链表的头节点，头节点尝尝用来作为链表的接入点）。<br>图中另外一个值得注意的地方是，链表的尾元素指向一个null节点。然而要标识出链表的起始节点却有点麻烦，需要链表的实现都是在链表最前面有一个特殊节点，叫做头节点。经过改造之后，图6-1中的链表成了下面的样子<br><img src="http://7xnv26.com1.z0.glb.clouddn.com/image/jpg/6-2.png" alt="图6-2"><br>链表中插入一个节点的效率很高。向链表中插入一个节点，需要修改它前面的节点(前驱),使其指向新加入的节点，而新加入的节点则指向原来前驱指向的节点。图6-3演示了如何在eggs后加入cookies。<br><img src="http://7xnv26.com1.z0.glb.clouddn.com/image/jpg/6-3.png" alt="图6-3"><br>从链表中删除一个元素也很简单。将待删除元素的前驱节点指向待删除元素的后继节点，同时将待删除元素指向null，元素就删除成功了。图6-4演示了从链表中删除“bacon”的过程。<br><img src="http://7xnv26.com1.z0.glb.clouddn.com/image/jpg/6-4.png" alt="图6-4"><br>链表还有其他一些操作,但插入和删除元素最能说明链表为什么如此有用。</p>
<h4 id="6-3-设计一个基于对象的链表"><a href="#6-3-设计一个基于对象的链表" class="headerlink" title="6.3 设计一个基于对象的链表"></a>6.3 设计一个基于对象的链表</h4><p>我们设计的链包包含两个类。Node类用来表示节点，LinkedList类提供了插入节点、删除节点、显示列表元素的方法，以及其他一些辅助方法。</p>
<h4 id="6-3-1-Node类"><a href="#6-3-1-Node类" class="headerlink" title="6.3.1 Node类"></a>6.3.1 Node类</h4><p>Node类包含两个属性：element用来保存节点上的数据，next用来保存指向下一个节点的链接。我们使用一个构造函数来创建节点，该构造函数设置了这两个属性的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.element = element;</span><br><span class="line">   <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-3-2-LinkedList类"><a href="#6-3-2-LinkedList类" class="headerlink" title="6.3.2 LinkedList类"></a>6.3.2 LinkedList类</h4><p>LList类提供了对链表进行操作的方法。该类的功能包括插入删除节点、在列表中查找给定的值。该类也有一个构造函数，链表只有一个属性，那就是使用一个Node对象来保存该链表的头节点。<br>该类的构造函数如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">   <span class="keyword">this</span>.find = find;</span><br><span class="line">   <span class="keyword">this</span>.insert = insert;</span><br><span class="line">   <span class="keyword">this</span>.remove = remove;</span><br><span class="line">   <span class="keyword">this</span>.display = display;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>head节点的next属性被初始化为null，当有新元素插入时，next会指向新的元素，所以在这里我们没有修改next的值。</p>
<h4 id="6-3-3-插入新节点"><a href="#6-3-3-插入新节点" class="headerlink" title="6.3.3 插入新节点"></a>6.3.3 插入新节点</h4><p>我们要分析的第一个方法是insert，该方法向链表中插入一个节点。向链表中插入新节点时，需要明确指出要在哪个节点前面或后面插入。首先介绍如何在一个已知节点后面插入元素。<br>在一个已知节点后面插入元素时，先要找到“后面”的节点。为此，创建一个辅助方法find()，该方法遍历链表，查找给定数据。如果找到数据，该方法就返回保存该数据的节点。find()方法的实现代码如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">   <span class="keyword">while</span>(currNode.element != item)&#123;</span><br><span class="line">      currNode = currNode.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>find()方法演示了如何在链表上进行移动。首先，创建一个新节点，并将链表的头节点赋给这个新创建的节点。然后在链表上进行循环，如果当前节点的element属性和我们要找的信息不符，就从当前节点移动到下一个节点。如果查找成功，该方法返回包含该数据的节点；否则，返回null。<br>一旦找到“后面”的节点，就可以将新节点插入链表了。首先，将新节点的next属性设置为“后面”节点的next属性对应的值。然后设置“后面”节点的next属性指向新节点。insert()方法的定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newElement,item</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">   <span class="keyword">var</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">   newNode.next = current.next;</span><br><span class="line">   current.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在已经可以开始测试我们的链表实现了。然而在测试之前，先来定义一个display()方法，该方法用来显示链表中的元素：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">   <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currNode.next.element);</span><br><span class="line">      currNode = currNode.next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法先将列表的头节点赋给一个变量，然后循环遍历链表，当前节点的next属性为null时循环结束。为了只显示包含数据的节点（换句话说，不显示头节点），程序只访问当前节点的下一个节点中保存的数据：<br><code>currNode.next.element</code><br>最后，再加一点代码，来试试新定义的链表。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.element = element;</span><br><span class="line">   <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">   <span class="keyword">this</span>.find = find;</span><br><span class="line">   <span class="keyword">this</span>.insert = insert;</span><br><span class="line">   <span class="keyword">this</span>.remove = remove;</span><br><span class="line">   <span class="keyword">this</span>.display = display;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">   <span class="keyword">while</span>(currNode.element != item)&#123;</span><br><span class="line">      currNode = currNode.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newElement,item</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">   <span class="keyword">var</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">   newNode.next = current.next;</span><br><span class="line">   current.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">   <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currNode.next.element);</span><br><span class="line">      currNode = currNode.next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cities = <span class="keyword">new</span> LList();</span><br><span class="line">cities.insert(<span class="string">"Conway"</span>, <span class="string">"head"</span>);</span><br><span class="line">cities.insert(<span class="string">"Russellville"</span>, <span class="string">"Conway"</span>);</span><br><span class="line">cities.insert(<span class="string">"Alma"</span>, <span class="string">"Russellville"</span>);</span><br><span class="line">cities.display();</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//Conway、Russellville、Alma</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-3-4-从链表中删除一个节点"><a href="#6-3-4-从链表中删除一个节点" class="headerlink" title="6.3.4 从链表中删除一个节点"></a>6.3.4 从链表中删除一个节点</h4><p>从链表中删除节点时，需要先找到待删除节点前面的节点。找到这个节点后，修改它的next属性，使其不再指向待删除节点，而是指向待删除节点的下一个节点。我们可以定义一个方法findPrevious()，来做这件事。该方法遍历链表中的元素，检查每一个节点的下一个节点中是否存储着待删除数据。如果找到，返回该节点(即“前一个”节点)，这样就可以修改它的next属性了。findPrevious()方法的定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPrevious</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">   <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>) &amp;&amp; (currNode.next.element != item))&#123;</span><br><span class="line">      currNode = currNode.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在就可以开始写move()方法了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> prevNode = <span class="keyword">this</span>.findPrevious(item);</span><br><span class="line">   <span class="keyword">if</span> (!prevNode.next == <span class="literal">null</span>) &#123;</span><br><span class="line">      prevNode.next = prevNode.next.next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法中最重要的一行代码如下,看起来有点奇怪,但是完全说得通:<br><code>prevNode.next = prevNode.next.next;</code><br>这里跳过了待删除节点，让“前一个”节点指向了待删除节点的后一个节点。<br>如果对这个操作还是不太了解，可参考图6-4，图片看起来更加形象。<br>修改LList()类的构造函数，使其包含这两个新加的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">   <span class="keyword">this</span>.find = find;</span><br><span class="line">   <span class="keyword">this</span>.insert = insert;</span><br><span class="line">   <span class="keyword">this</span>.display = display;</span><br><span class="line">   <span class="keyword">this</span>.findPrevious = findPrevious;</span><br><span class="line">   <span class="keyword">this</span>.remove = remove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-4-双向链表"><a href="#6-4-双向链表" class="headerlink" title="6.4 双向链表"></a>6.4 双向链表</h4><p>尽管从链表的头节点遍历到尾节点很简单,但反过来,从后向前遍历则没那么简单。通过 给 Node 对象增加一个属性,该属性存储指向前驱节点的链接,这样就容易多了。此时向链 表插入一个节点需要更多的工作,我们需要指出该节点正确的前驱和后继。但是在从链表 中删除节点时,效率提高了,不需要再查找待删除节点的前驱节点了。图 6-5 演示了双向 链表的工作原理。<br>尽管从链表的头节点遍历到尾节点很简单，但反过来，从后向前遍历则没那么简单。通过给Node对象增加一个属性，该属性存储指向前驱节点的链接，这样就容易多了。此时向链表插入一个节点需要更多的工作，我们需要指出该节点正确的前驱和后继。但是在从链表中删除节点时，效率提高了，不需要再查找待删除节点的前驱节点了。图6-5演示了双向链表的工作原理。<br><img src="http://7xnv26.com1.z0.glb.clouddn.com/image/jpg/
6-5.png" alt="图6-5"><br>首当其冲的是要为 Node 类增加一个 previous 属性:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.element = element;</span><br><span class="line">   <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">this</span>.previous = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>双向链表的insert()方法和单向链表的类似,但是需要设置新节点的 previous属性,使其指向该节点的前驱。该方法的定义如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newElement, item</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> newNoede = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">   <span class="keyword">var</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">   newNode.next = current.next;</span><br><span class="line">   newNode.previous = current;</span><br><span class="line">   current.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>双向链表的remove()方法比单向链表的效率更高，因为不需要再查找前驱节点了。首先需要在链表中找出存储待删除数据的节点，然后设置该节点前驱的next属性，使其指向待删除节点的后继；设置该节点后继的previous属性，使其指向待删除节点的前驱。图6-6直观地展示了该过程。<br><img src="http://7xnv26.com1.z0.glb.clouddn.com/image/jpg/
6-6.png" alt="图6-6"><br>remove()方法定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> currNode = <span class="keyword">this</span>.find(item);</span><br><span class="line">   <span class="keyword">if</span> (!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">      currNode.previous.next = currNode.next;</span><br><span class="line">      currNode.next.previous = currNode.previous;</span><br><span class="line">      currNode.next = <span class="literal">null</span>;</span><br><span class="line">      currNode.previous = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了完成以反序显示链条中元素这类任务，需要给双向链表正加一个工具方法，用来查找最后的节点。findLast()方法找出了链表中的最后一个节点，同时免除了从前往后遍历链表之苦：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLast</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">   <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>))&#123;</span><br><span class="line">      currNode = currNode.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了这个工具方法，就可以写一个方法，反序显示双向链表中的元素。dispReverse()方法如下所示:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispReverse</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">   currNode = <span class="keyword">this</span>.findList();</span><br><span class="line">   <span class="keyword">while</span>(!(currNode.previous == <span class="literal">null</span>))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currNode.element);</span><br><span class="line">      currNode = currNode.previous;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-5-循环链表"><a href="#6-5-循环链表" class="headerlink" title="6.5 循环链表"></a>6.5 循环链表</h4><p>循环链表和单向链表相似,节点类型都是一样的。唯一的区别是,在创建循环链表时,让<br>其头节点的 next 属性指向它本身,即: head.next = head<br>这种行为会传导至链表中的每个节点,使得每个节点的 next 属性都指向链表的头节点。换 句话说,链表的尾节点指向头节点,形成了一个循环链表,如图 6-7 所示。<br>循环链表和单向链表相似，节点类型都是一样的。唯一的区别是，在创建循环链表时，让其头节点的next属性指向它本身，即：head.next = head;这种行为会传导至链表中的每个节点，使得每个节点next属性都指向链表的头节点。换句话说，链表的尾节点指向头节点，形成了一个循环链表。如图6-7所示。<br><img src="http://7xnv26.com1.z0.glb.clouddn.com/image/jpg/6-7.png" alt="图6-7"><br>从后向前遍历链表。 创建循环链表,只需要修改 LList 类的构造函数:<br>如果你希望可以从后向前遍历链表，但是又不想付出额外代价来创建一个双向链表，那么就需要使用循环链表。从循环链表的尾节点向后移动，就等于从后向前遍历链表。创建循环链表，只需要修改LList类的构造函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">  <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">this</span>.find = find;</span><br><span class="line">  <span class="keyword">this</span>.insert = insert;</span><br><span class="line">  <span class="keyword">this</span>.display = display;</span><br><span class="line">  <span class="keyword">this</span>.findPrevious = findPrevious;</span><br><span class="line">  <span class="keyword">this</span>.remove = remove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要修改一处，就将单向链表变成了循环链表。但是其他一些方法需要修改才能工作正常。比如，display()就需要修改，原来的方式在循环链表里会陷入死循环。while循环的循环条件需要修改，需要检查头节点，当循环到头节点时退出循环。<br>循环链表的display()方法如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>) &amp;&amp; !(currNode.next.element == <span class="string">"head"</span>))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(currNode.next.element);</span><br><span class="line">    currNode = currNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>
  </div>
  
<nav id="article-nav">
  
    <a href="/2016/05/12/data-structure-fourteen/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          数据结构与算法javascript描述学习笔记（14）
        
      </div>
    </a>
  
  
    <a href="/2016/05/06/data-structure-twelve/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">数据结构与算法javascript描述学习笔记（12）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

</article>


<div class="duoshuo">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="data-structure-thirteen" data-title="数据结构与算法javascript描述学习笔记（13）" data-url="http://www.yuanye097.com/2016/05/10/data-structure-thirteen/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script>var duoshuoQuery={short_name:"yuanye097"};</script>
  <script src="http://static.duoshuo.com/embed.js"></script>
  <!-- 多说公共JS代码 end -->
</div>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 荡漾
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="http://7xnv26.com1.z0.glb.clouddn.com/yuanye/fancybox/jquery.fancybox.css">

<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7xnv26.com1.z0.glb.clouddn.com/yuanye/js/require.js"></script>
<script src="http://7xnv26.com1.z0.glb.clouddn.com/yuanye/js/jquery.js"></script>
<script src="http://7xnv26.com1.z0.glb.clouddn.com/yuanye/js/main.js"></script>

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-60686330-2', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1994efadc3f3d033974da07965940a2f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>